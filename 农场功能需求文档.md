# KekeSwap 农场功能需求文档

## 1. 项目概述

### 1.1 功能定位
KekeSwap 农场模块是平台的核心DeFi功能之一，允许用户质押LP代币获得KEKE代币奖励，实现流动性挖矿和收益农场功能。

### 1.2 业务目标
- 激励用户为平台提供流动性
- 通过KEKE代币奖励建立用户粘性
- 构建可持续的DeFi生态系统
- 提供多样化的收益机会

## 2. 技术架构

### 2.1 智能合约层

#### 2.1.1 Master合约 (主农场合约)
- **合约地址管理**: 通过 `src/hooks/useContract.ts` 统一管理
- **主要功能**:
  - `deposit(pid, amount)`: 质押LP代币
  - `withdraw(pid, amount)`: 提取LP代币
  - `enterStaking(amount)`: 质押KEKE代币
  - `leaveStaking(amount)`: 提取KEKE代币
  - `getPoolKEKEReward(pid, user)`: 查询待收获奖励
  - `poolInfo(pid)`: 获取池子信息
  - `userInfo(pid, user)`: 获取用户信息

#### 2.1.2 SmartChef合约 (单币质押合约)
- **主要功能**:
  - `deposit(amount)`: 质押代币
  - `withdraw(amount)`: 提取代币
  - `pendingReward(user)`: 查询待收获奖励
  - `userInfo(user)`: 获取用户信息

### 2.2 前端架构

#### 2.2.1 页面结构
```
src/app/(web)/farm/
├── page.tsx                 # 主页面
├── components/              # 页面组件
│   ├── FarmPoolCard.tsx     # 农场池卡片
│   ├── StakeModal.tsx       # 质押弹窗
│   ├── UnstakeModal.tsx     # 取消质押弹窗
│   ├── HarvestModal.tsx     # 收获奖励弹窗
│   ├── FarmStats.tsx        # 农场统计
│   └── FarmGuide.tsx        # 使用指南
└── hooks/                   # 页面专用hooks
    ├── useFarmPools.ts      # 农场池数据
    ├── useFarmActions.ts    # 农场操作
    └── useFarmStats.ts     # 农场统计
```

#### 2.2.2 通用Hooks
```
src/hooks/
├── useMaster.ts             # Master合约交互
├── useSmartChef.ts          # SmartChef合约交互
└── useFarm.ts               # 农场综合功能
```

## 3. 功能需求

### 3.1 农场池展示

#### 3.1.1 池子列表
- **数据来源**: Master合约的poolInfo
- **显示信息**:
  - 池子名称 (如: KEKE-ETH LP)
  - 年化收益率 (APY)
  - 总锁定价值 (TVL)
  - 质押用户数量
  - 奖励代币类型
  - 池子状态 (活跃/暂停)

#### 3.1.2 用户数据
- **质押数量**: 用户在该池子的质押金额
- **待收获奖励**: 实时计算的KEKE奖励
- **已获得奖励**: 历史累计奖励

### 3.2 质押功能

#### 3.2.1 LP代币质押
- **前置条件**: 用户需要先在交易页面添加流动性获得LP代币
- **操作流程**:
  1. 选择要质押的农场池
  2. 输入质押数量
  3. 授权LP代币 
  4. 执行质押交易
  5. 交易确认后更新界面

#### 3.2.2 KEKE代币质押
- **特殊池子**: pid=0 的特殊池子用于KEKE代币质押
- **操作方式**: 使用 `enterStaking` 和 `leaveStaking` 函数

### 3.3 提取功能

#### 3.3.1 部分提取
- 用户可以提取部分质押的LP代币
- 自动收获当前待收获的奖励

#### 3.3.2 全部提取
- 提取所有质押的LP代币
- 自动收获所有待收获的奖励

### 3.4 奖励收获

#### 3.4.1 手动收获
- 用户可以单独收获奖励而不提取质押
- 使用 `deposit(pid, 0)` 实现

#### 3.4.2 自动复投
- 将收获的KEKE奖励自动质押到KEKE池子
- 实现复利效果

### 3.5 数据统计

#### 3.5.1 全局统计
- **总锁定价值**: 所有池子的TVL总和
- **活跃用户数**: 有质押的用户总数
- **平均APY**: 加权平均年化收益率
- **总奖励发放**: 历史累计KEKE奖励

#### 3.5.2 个人统计
- **总质押价值**: 用户在所有池子的质押总价值
- **总待收获奖励**: 所有池子的待收获奖励总和
- **历史收益**: 用户的历史收益记录

## 4. 技术实现规范

### 4.1 Hook开发规范

#### 4.1.1 useMaster.ts 实现要求
```typescript
interface UseMasterReturn {
  // 读取函数
  getPoolInfo: (pid: number) => PoolInfo | undefined;
  getUserInfo: (pid: number, user: string) => UserInfo | undefined;
  getPendingReward: (pid: number, user: string) => bigint | undefined;
  getPoolLength: () => number | undefined;
  
  // 写入函数
  deposit: (pid: number, amount: string) => Promise<void>;
  withdraw: (pid: number, amount: string) => Promise<void>;
  enterStaking: (amount: string) => Promise<void>;
  leaveStaking: (amount: string) => Promise<void>;
  
  // 状态
  isLoading: boolean;
  isSuccess: boolean;
  error: string | null;
  txHash: string | undefined;
}
```

#### 4.1.2 useSmartChef.ts 实现要求
```typescript
interface UseSmartChefReturn {
  // 读取函数
  getUserInfo: (user: string) => SmartChefUserInfo | undefined;
  getPendingReward: (user: string) => bigint | undefined;
  getPoolInfo: () => SmartChefPoolInfo | undefined;
  
  // 写入函数
  deposit: (amount: string) => Promise<void>;
  withdraw: (amount: string) => Promise<void>;
  
  // 状态
  isLoading: boolean;
  isSuccess: boolean;
  error: string | null;
  txHash: string | undefined;
}
```

### 4.2 组件开发规范

#### 4.2.1 FarmPoolCard组件
- **Props接口**:
```typescript
interface FarmPoolCardProps {
  poolId: number;
  poolInfo: PoolInfo;
  userInfo?: UserInfo;
  onStake: (amount: string) => void;
  onUnstake: (amount: string) => void;
  onHarvest: () => void;
}
```

#### 4.2.2 样式规范
- 使用Tailwind CSS进行样式开发
- 遵循现有的设计系统和颜色规范
- 保持与其他页面的视觉一致性
- 响应式设计，支持移动端

### 4.3 数据类型定义

```typescript
// 池子信息
interface PoolInfo {
  lpToken: string;
  allocPoint: bigint;
  lastRewardBlock: bigint;
  accKekePerShare: bigint;
}

// 用户信息
interface UserInfo {
  amount: bigint;
  rewardDebt: bigint;
}

// SmartChef池子信息
interface SmartChefPoolInfo {
  stakedToken: string;
  rewardToken: string;
  rewardPerBlock: bigint;
  startBlock: bigint;
  bonusEndBlock: bigint;
  poolLimitPerUser: bigint;
}

// SmartChef用户信息
interface SmartChefUserInfo {
  amount: bigint;
  rewardDebt: bigint;
}
```

## 5. 用户体验设计

### 5.1 交互流程

#### 5.1.1 新用户引导
1. 显示"如何开始农场挖矿"指南
2. 引导用户先添加流动性
3. 说明质押和收获流程

#### 5.1.2 操作反馈
- **Loading状态**: 交易提交后显示加载动画
- **成功提示**: 交易确认后显示成功消息
- **错误处理**: 清晰的错误信息和解决建议

### 5.2 数据展示

#### 5.2.1 实时更新
- 使用WebSocket或定时轮询更新数据
- 奖励数据实时计算和显示
- 价格和APY实时更新

#### 5.2.2 数据格式化
- 代币数量使用合适的小数位数
- 大数值使用K、M、B等单位
- 百分比显示保留2位小数

## 6. 安全考虑

### 6.1 前端安全
- 输入验证：数量必须大于0且不超过余额
- 授权检查：确保用户已授权足够的代币
- 滑点保护：提醒用户注意价格变化

### 6.2 合约交互安全
- 使用try-catch处理合约调用错误
- 验证交易参数的合法性
- 处理网络错误和超时情况

## 7. 性能优化

### 7.1 数据缓存
- 使用React Query缓存合约数据
- 合理设置缓存时间和更新策略
- 避免重复的合约调用

### 7.2 组件优化
- 使用React.memo优化组件渲染
- 合理使用useCallback和useMemo
- 懒加载非关键组件

## 8. 测试要求

### 8.1 单元测试
- Hook函数的测试覆盖
- 组件渲染和交互测试
- 数据处理逻辑测试

### 8.2 集成测试
- 完整的用户操作流程测试
- 合约交互的端到端测试
- 错误场景的处理测试

## 9. 部署和监控

### 9.1 部署要求
- 确保合约地址配置正确
- 验证不同网络的兼容性
- 测试网络和主网的功能一致性

### 9.2 监控指标
- 页面加载时间
- 交易成功率
- 用户操作转化率
- 错误发生频率

## 10. 开发时间线

### 第一阶段 (3天)
- 创建基础Hook (useMaster.ts, useSmartChef.ts)
- 实现农场池列表展示
- 基础的质押和提取功能

### 第二阶段 (2天)
- 完善用户界面和交互
- 添加数据统计功能
- 实现奖励收获功能

### 第三阶段 (2天)
- 优化用户体验
- 添加错误处理和加载状态
- 测试和bug修复

### 第四阶段 (1天)
- 代码审查和优化
- 文档完善
- 部署准备

## 11. 验收标准

### 11.1 功能完整性
- [ ] 农场池列表正确显示
- [ ] 质押功能正常工作
- [ ] 提取功能正常工作
- [ ] 奖励收获功能正常工作
- [ ] 数据统计准确显示

### 11.2 用户体验
- [ ] 界面美观且响应式
- [ ] 操作流程清晰直观
- [ ] 错误提示友好明确
- [ ] 加载状态合理显示

### 11.3 技术质量
- [ ] 代码结构清晰规范
- [ ] Hook复用性良好
- [ ] 性能表现优秀
- [ ] 安全性考虑充分

---

**注意**: 本文档基于当前项目的技术栈和架构设计，在实际开发过程中可能需要根据具体情况进行调整和优化。