"use client";

import { useState, useEffect, useCallback } from 'react';
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { useAccount } from "wagmi";
import { useTrading } from '../hooks/useTrading';
import { useTokenConfig } from '@/hooks/tokens/useTokenConfig';
import { useKekeswapRouterAddress } from '@/hooks/useContract';
import { formatUnits } from 'viem';
import { toast } from 'sonner';

interface TradingPanelProps {
  symbol?: string;
  currentPrice?: string;
}

export default function TradingPanel({ symbol = "KEKE", currentPrice = "0.42814" }: TradingPanelProps) {
  const { address, isConnected } = useAccount();
  const [buyAmount, setBuyAmount] = useState("");
  const [sellAmount, setSellAmount] = useState("");
  const [buyPrice, setBuyPrice] = useState(currentPrice);
  const [sellPrice, setSellPrice] = useState(currentPrice);
  const [needsApproval, setNeedsApproval] = useState(false);
  const [memeTokenInfo, setMemeTokenInfo] = useState<any>(null);

  // Ëé∑ÂèñÁ≥ªÁªü‰ª£Â∏Å‰ø°ÊÅØ
  const { tokenInfo: systemTokenInfo, loading: systemTokenLoading } = useTokenConfig(symbol);
  // Ëé∑Âèñ ETH ‰ø°ÊÅØÔºà‰∫§ÊòìÂØπÔºâ
  const { tokenInfo: ethInfo } = useTokenConfig("WETH");

  // Â¶ÇÊûú‰∏çÊòØÁ≥ªÁªü‰ª£Â∏ÅÔºåÂ∞ùËØï‰ªé meme ‰ª£Â∏ÅËé∑Âèñ
  useEffect(() => {
    const fetchMemeTokenInfo = async () => {
      if (systemTokenInfo || systemTokenLoading) return; // Â¶ÇÊûúÂ∑≤ÁªèÊâæÂà∞Á≥ªÁªü‰ª£Â∏ÅÔºå‰∏çÈúÄË¶ÅÊü•ËØ¢ meme ‰ª£Â∏Å
      
      try {
        // ÂÖàÂ∞ùËØïÈÄöËøá symbol ÊêúÁ¥¢
        const searchResponse = await fetch(`/api/meme-tokens?action=search&search=${symbol}`);
        const searchResult = await searchResponse.json();
        if (searchResult.success && searchResult.data.tokens.length > 0) {
          // ÊâæÂà∞ÂåπÈÖçÁöÑ meme ‰ª£Â∏Å
          const exactMatch = searchResult.data.tokens.find((token: any) => {
            return token.symbol.toLowerCase() === symbol.toLowerCase()
          }                        
          );
          
          if (exactMatch) {
            setMemeTokenInfo(exactMatch);
            console.log('ÊâæÂà∞ meme ‰ª£Â∏Å:', exactMatch);
          }
        }
      } catch (error) {
        console.error('Ëé∑Âèñ meme ‰ª£Â∏Å‰ø°ÊÅØÂ§±Ë¥•:', error);
      }
    };

    fetchMemeTokenInfo();
  }, [symbol, systemTokenInfo, systemTokenLoading]);

  // ÂΩìÂâç‰ª£Â∏Å‰ø°ÊÅØÔºà‰ºòÂÖà‰ΩøÁî®Á≥ªÁªü‰ª£Â∏ÅÔºåÂÖ∂Ê¨°ÊòØ meme ‰ª£Â∏ÅÔºâ
  const currentTokenInfo = systemTokenInfo || memeTokenInfo;
  
  // Ëé∑Âèñ‰ª£Â∏ÅÂ∞èÊï∞‰ΩçÊï∞
  const getTokenDecimals = useCallback((tokenSymbol: string) => {
    if ((tokenSymbol === "ETH" || tokenSymbol === "WETH") && ethInfo) return ethInfo.decimals;
    if (tokenSymbol === symbol && currentTokenInfo) return currentTokenInfo.decimals;
    // ÈªòËÆ§ÂÄºÔºöETH/WETH 18‰ΩçÔºåÂÖ∂‰ªñ 18‰Ωç
    return 18;
  }, [ethInfo, symbol, currentTokenInfo]);

  const {
    isLoading,
    transactionStatus,
    isConfirming,
    isConfirmed,
    shouldUseNativeETH,
    useTokenBalance,
    useTokenAllowance,
    approveToken,
    executeBuy,
    executeSell,
    refreshBalances,
  } = useTrading();

  // Ëé∑Âèñ‰ª£Â∏Å‰ΩôÈ¢ù
  const { data: tokenBalance, refetch: refetchTokenBalance } = useTokenBalance(symbol);
  const { data: ethBalance, refetch: refetchETHBalance } = useTokenBalance("WETH");
  
  // Âä®ÊÄÅËé∑ÂèñË∑ØÁî±Âú∞ÂùÄ
  const routerAddress = useKekeswapRouterAddress();
  
  // Ëé∑ÂèñÊéàÊùÉÁä∂ÊÄÅ
  const { data: ethAllowance } = useTokenAllowance("WETH", routerAddress || "0x0");
  const { data: tokenAllowance } = useTokenAllowance(symbol, routerAddress || "0x0");

  // Ê†ºÂºèÂåñ‰ΩôÈ¢ùÊòæÁ§∫ - ‰ΩøÁî®Ê≠£Á°ÆÁöÑÂ∞èÊï∞‰ΩçÊï∞
  const formatBalance = useCallback((balance: unknown, tokenSymbol: string) => {
    if (!balance || typeof balance !== 'bigint') return "0.00";
    const decimals = getTokenDecimals(tokenSymbol);
    return parseFloat(formatUnits(balance, decimals)).toFixed(decimals === 6 ? 6 : 4);
  }, [getTokenDecimals]);

  const balances = {
    [symbol]: formatBalance(tokenBalance, symbol),
    ETH: formatBalance(ethBalance, "WETH"),
  };

  // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊéàÊùÉ
  useEffect(() => {
    if (buyAmount && buyPrice) {
      // Â¶ÇÊûú‰ΩøÁî®ÂéüÁîü ETHÔºå‰∏çÈúÄË¶ÅÊéàÊùÉ
      if (shouldUseNativeETH) {
        setNeedsApproval(false);
        return;
      }
      
      // Ê£ÄÊü• ETH/WETH ÊéàÊùÉ
      if (ethAllowance && typeof ethAllowance === 'bigint') {
        const totalETH = parseFloat(buyAmount) * parseFloat(buyPrice);
        const ethDecimals = getTokenDecimals("WETH");
        const allowanceFormatted = parseFloat(formatUnits(ethAllowance, ethDecimals));
        setNeedsApproval(totalETH > allowanceFormatted);
      } else {
        setNeedsApproval(true); // Â¶ÇÊûúÊó†Ê≥ïËé∑ÂèñÊéàÊùÉÁä∂ÊÄÅÔºåÈªòËÆ§ÈúÄË¶ÅÊéàÊùÉ
      }
    } else {
      setNeedsApproval(false);
    }
  }, [buyAmount, buyPrice, ethAllowance, getTokenDecimals, shouldUseNativeETH]);

  // ÁõëÂê¨‰∫§ÊòìÁ°ÆËÆ§Áä∂ÊÄÅÔºåËá™Âä®Âà∑Êñ∞‰ΩôÈ¢ù
  useEffect(() => {
    if (isConfirmed) {
      console.log('üîÑ ‰∫§ÊòìÂ∑≤Á°ÆËÆ§ÔºåËá™Âä®Âà∑Êñ∞‰ΩôÈ¢ù...');
      const refreshTimer = setTimeout(() => {
        refreshBalances();
        toast.success('‰ΩôÈ¢ùÂ∑≤Êõ¥Êñ∞ÔºÅ');
      }, 2000);
      
      return () => clearTimeout(refreshTimer);
    }
  }, [isConfirmed, refreshBalances]);

  const calculateTotal = (amount: string, price: string) => {
    const numAmount = parseFloat(amount) || 0;
    const numPrice = parseFloat(price) || 0;
    return (numAmount * numPrice).toFixed(4);
  };

  const handleBuy = async () => {
    if (!buyAmount || !buyPrice) {
      toast.error('ËØ∑ËæìÂÖ•‰π∞ÂÖ•Êï∞ÈáèÂíå‰ª∑Ê†º');
      return;
    }
    
    if (!currentTokenInfo) {
      toast.error('‰ª£Â∏Å‰ø°ÊÅØÂä†ËΩΩ‰∏≠ÔºåËØ∑Á®çÂÄôÈáçËØï');
      return;
    }

    try {
      // Â¶ÇÊûúÈúÄË¶ÅÊéàÊùÉÔºåÂÖàÊâßË°åÊéàÊùÉ
      if (needsApproval && !shouldUseNativeETH) {
        toast.info('Ê≠£Âú®ÊéàÊùÉ ETH...');
        const totalETH = (parseFloat(buyAmount) * parseFloat(buyPrice)).toString();
        const approved = await approveToken("WETH", totalETH);
        if (!approved) {
          toast.error('ÊéàÊùÉÂ§±Ë¥•ÔºåÊó†Ê≥ïÁªßÁª≠‰π∞ÂÖ•');
          return;
        }
        toast.success('ÊéàÊùÉÊàêÂäüÔºÅÂºÄÂßã‰π∞ÂÖ•...');
      }

      console.log('üõí ÂºÄÂßã‰π∞ÂÖ•‰∫§Êòì:', {
        symbol,
        currentTokenInfo,
        buyAmount,
        buyPrice,
        needsApproval,
        shouldUseNativeETH,
      });
      
      // ÊâßË°å‰π∞ÂÖ• - Áªü‰∏Ä‰ΩøÁî® currentTokenInfo
      const success = await executeBuy({
        tokenSymbol: symbol,
        systemTokenInfo: currentTokenInfo,
        amount: buyAmount,
        price: buyPrice,
        type: 'buy'
      });

      if (success) {
        // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
        setBuyAmount("");
        // ÊâãÂä®Ëß¶Âèë‰ΩôÈ¢ùÂà∑Êñ∞
        setTimeout(() => {
          refreshBalances();
        }, 1000);
      }
    } catch (error) {
      console.error('‰π∞ÂÖ•ÊµÅÁ®ãÂ§±Ë¥•:', error);
      toast.error('‰π∞ÂÖ•ÊµÅÁ®ãÂ§±Ë¥•');
    }
  };

  const handleSell = async () => {
    if (!sellAmount || !sellPrice) {
      toast.error('ËØ∑ËæìÂÖ•ÂçñÂá∫Êï∞ÈáèÂíå‰ª∑Ê†º');
      return;
    }
    
    if (!currentTokenInfo) {
      toast.error('‰ª£Â∏Å‰ø°ÊÅØÂä†ËΩΩ‰∏≠ÔºåËØ∑Á®çÂÄôÈáçËØï');
      return;
    }

    try {
      // Ê£ÄÊü•‰ΩôÈ¢ùÊòØÂê¶Ë∂≥Â§ü
      if (tokenBalance && typeof tokenBalance === 'bigint') {
        const tokenDecimals = getTokenDecimals(symbol);
        const balanceFormatted = parseFloat(formatUnits(tokenBalance, tokenDecimals));
        if (parseFloat(sellAmount) > balanceFormatted) {
          toast.error(`‰ΩôÈ¢ù‰∏çË∂≥ÔºÅÂΩìÂâç‰ΩôÈ¢ù: ${balanceFormatted.toFixed(4)} ${symbol}`);
          return;
        }
      }

      // Ê£ÄÊü•‰ª£Â∏ÅÊéàÊùÉ
      if (tokenAllowance && typeof tokenAllowance === 'bigint') {
        const tokenDecimals = getTokenDecimals(symbol);
        const allowanceFormatted = parseFloat(formatUnits(tokenAllowance, tokenDecimals));
        if (parseFloat(sellAmount) > allowanceFormatted) {
          toast.info(`Ê≠£Âú®ÊéàÊùÉ ${symbol}...`);
          const approved = await approveToken(symbol, sellAmount);
          if (!approved) {
            toast.error('ÊéàÊùÉÂ§±Ë¥•ÔºåÊó†Ê≥ïÁªßÁª≠ÂçñÂá∫');
            return;
          }
          toast.success('ÊéàÊùÉÊàêÂäüÔºÅÂºÄÂßãÂçñÂá∫...');
        }
      } else {
        // Â¶ÇÊûúÊó†Ê≥ïËé∑ÂèñÊéàÊùÉÁä∂ÊÄÅÔºåÂ∞ùËØïÊéàÊùÉ
        toast.info(`Ê≠£Âú®ÊéàÊùÉ ${symbol}...`);
        const approved = await approveToken(symbol, sellAmount);
        if (!approved) {
          toast.error('ÊéàÊùÉÂ§±Ë¥•ÔºåÊó†Ê≥ïÁªßÁª≠ÂçñÂá∫');
          return;
        }
      }

      console.log('üí∞ ÂºÄÂßãÂçñÂá∫‰∫§Êòì:', {
        symbol,
        currentTokenInfo,
        sellAmount,
        sellPrice,
      });

      // ÊâßË°åÂçñÂá∫ - Áªü‰∏Ä‰ΩøÁî® currentTokenInfo
      const success = await executeSell({
        tokenSymbol: symbol,
        systemTokenInfo: currentTokenInfo,
        amount: sellAmount,
        price: sellPrice,
        type: 'sell'
      });

      if (success) {
        // Ê∏ÖÁ©∫ËæìÂÖ•Ê°Ü
        setSellAmount("");
        // ÊâãÂä®Ëß¶Âèë‰ΩôÈ¢ùÂà∑Êñ∞
        setTimeout(() => {
          refreshBalances();
        }, 1000);
      }
    } catch (error) {
      console.error('ÂçñÂá∫ÊµÅÁ®ãÂ§±Ë¥•:', error);
      toast.error('ÂçñÂá∫ÊµÅÁ®ãÂ§±Ë¥•');
    }
  };

  return (
    <Card className="bg-gray-900 text-white border-gray-700">
      <CardHeader className="pb-4">
        <CardTitle className="text-lg">Áé∞Ë¥ß‰∫§Êòì</CardTitle>
        <div className="space-y-2">
          <div className="flex gap-2 text-sm">
            <span className="text-gray-400">ÂèØÁî®‰ΩôÈ¢ù:</span>
            <span>{symbol}: {balances[symbol]}</span>
            <span>{shouldUseNativeETH ? 'ETH' : 'WETH'}: {balances.ETH}</span>
          </div>
          
          <div className="flex gap-2 items-center">
            {!currentTokenInfo && (
              <Badge variant="outline" className="text-xs text-yellow-400 border-yellow-400">
                ‰ª£Â∏Å‰ø°ÊÅØÂä†ËΩΩ‰∏≠...
              </Badge>
            )}
            
            {shouldUseNativeETH && (
              <Badge variant="outline" className="text-xs text-blue-400 border-blue-400">
                ‰ΩøÁî®ÂéüÁîü ETH
              </Badge>
            )}
            
            {transactionStatus === 'pending' && (
              <Badge variant="outline" className="text-xs text-orange-400 border-orange-400">
                ‰∫§ÊòìÂ§ÑÁêÜ‰∏≠...
              </Badge>
            )}
            
            {transactionStatus === 'success' && (
              <Badge variant="outline" className="text-xs text-green-400 border-green-400">
                ‰∫§ÊòìÂ∑≤Êèê‰∫§
              </Badge>
            )}
            
            {isConfirming && (
              <Badge variant="outline" className="text-xs text-blue-400 border-blue-400">
                Á≠âÂæÖÁ°ÆËÆ§...
              </Badge>
            )}
            
            {isConfirmed && (
              <Badge variant="outline" className="text-xs text-green-400 border-green-400">
                ‰∫§ÊòìÂ∑≤Á°ÆËÆ§
              </Badge>
            )}
          </div>
        </div>
      </CardHeader>
      <CardContent>
        <Tabs defaultValue="buy" className="w-full">
          <TabsList className="grid w-full grid-cols-2 bg-gray-800">
            <TabsTrigger value="buy" className="text-green-400 data-[state=active]:bg-green-600">
              ‰π∞ÂÖ• {symbol}
            </TabsTrigger>
            <TabsTrigger value="sell" className="text-red-400 data-[state=active]:bg-red-600">
              ÂçñÂá∫ {symbol}
            </TabsTrigger>
          </TabsList>

          {/* ‰π∞ÂÖ•Èù¢Êùø */}
          <TabsContent value="buy" className="space-y-4 mt-6">
            <div className="space-y-3">
              <div>
                <label className="text-sm text-gray-400 mb-2 block">‰ª∑Ê†º (ETH)</label>
                <Input
                  type="number"
                  value={buyPrice}
                  onChange={(e) => setBuyPrice(e.target.value)}
                  className="bg-gray-800 border-gray-600 text-white"
                  placeholder="0.00"
                />
              </div>
              
              <div>
                <label className="text-sm text-gray-400 mb-2 block">Êï∞Èáè ({symbol})</label>
                <Input
                  type="number"
                  value={buyAmount}
                  onChange={(e) => setBuyAmount(e.target.value)}
                  className="bg-gray-800 border-gray-600 text-white"
                  placeholder="0.00"
                />
                <div className="flex gap-2 mt-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (buyPrice && balances.ETH) {
                        const maxTokens = (parseFloat(balances.ETH) * 0.25) / parseFloat(buyPrice);
                        setBuyAmount(maxTokens.toFixed(4));
                      }
                    }}
                    disabled={!buyPrice || !balances.ETH}
                  >
                    25%
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (buyPrice && balances.ETH) {
                        const maxTokens = (parseFloat(balances.ETH) * 0.5) / parseFloat(buyPrice);
                        setBuyAmount(maxTokens.toFixed(4));
                      }
                    }}
                    disabled={!buyPrice || !balances.ETH}
                  >
                    50%
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (buyPrice && balances.ETH) {
                        const maxTokens = (parseFloat(balances.ETH) * 0.75) / parseFloat(buyPrice);
                        setBuyAmount(maxTokens.toFixed(4));
                      }
                    }}
                    disabled={!buyPrice || !balances.ETH}
                  >
                    75%
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (buyPrice && balances.ETH) {
                        const maxTokens = parseFloat(balances.ETH) / parseFloat(buyPrice);
                        setBuyAmount(maxTokens.toFixed(4));
                      }
                    }}
                    disabled={!buyPrice || !balances.ETH}
                  >
                    ÊúÄÂ§ß
                  </Button>
                </div>
              </div>

              <div className="bg-gray-800 p-3 rounded-lg">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-400">ÊÄªËÆ° (ETH)</span>
                  <span className="text-white">{calculateTotal(buyAmount, buyPrice)}</span>
                </div>
                <div className="flex justify-between text-sm mt-1">
                  <span className="text-gray-400">ÊâãÁª≠Ë¥π (0.1%)</span>
                  <span className="text-white">{(parseFloat(calculateTotal(buyAmount, buyPrice)) * 0.001).toFixed(4)}</span>
                </div>
              </div>

              <Button
                onClick={handleBuy}
                className="w-full bg-green-600 hover:bg-green-700 text-white font-semibold py-3"
                disabled={!isConnected || !buyAmount || !buyPrice || isLoading || !currentTokenInfo}
              >
                {!isConnected 
                  ? "ËøûÊé•Èí±ÂåÖ" 
                  : !currentTokenInfo
                  ? "‰ª£Â∏ÅÂä†ËΩΩ‰∏≠..."
                  : isLoading || isConfirming
                  ? (isConfirming ? "Á°ÆËÆ§‰∏≠..." : "Â§ÑÁêÜ‰∏≠...")
                  : needsApproval && !shouldUseNativeETH
                  ? "ÊéàÊùÉÂπ∂‰π∞ÂÖ•"
                  : `‰π∞ÂÖ• ${symbol}`
                }
              </Button>
            </div>
          </TabsContent>

          {/* ÂçñÂá∫Èù¢Êùø */}
          <TabsContent value="sell" className="space-y-4 mt-6">
            <div className="space-y-3">
              <div>
                <label className="text-sm text-gray-400 mb-2 block">‰ª∑Ê†º (ETH)</label>
                <Input
                  type="number"
                  value={sellPrice}
                  onChange={(e) => setSellPrice(e.target.value)}
                  className="bg-gray-800 border-gray-600 text-white"
                  placeholder="0.00"
                />
              </div>
              
              <div>
                <label className="text-sm text-gray-400 mb-2 block">Êï∞Èáè ({symbol})</label>
                <Input
                  type="number"
                  value={sellAmount}
                  onChange={(e) => setSellAmount(e.target.value)}
                  className="bg-gray-800 border-gray-600 text-white"
                  placeholder="0.00"
                />
                <div className="flex gap-2 mt-2">
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (balances[symbol]) {
                        const amount = (parseFloat(balances[symbol]) * 0.25).toFixed(4);
                        setSellAmount(amount);
                      }
                    }}
                    disabled={!balances[symbol] || parseFloat(balances[symbol]) === 0}
                  >
                    25%
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (balances[symbol]) {
                        const amount = (parseFloat(balances[symbol]) * 0.5).toFixed(4);
                        setSellAmount(amount);
                      }
                    }}
                    disabled={!balances[symbol] || parseFloat(balances[symbol]) === 0}
                  >
                    50%
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (balances[symbol]) {
                        const amount = (parseFloat(balances[symbol]) * 0.75).toFixed(4);
                        setSellAmount(amount);
                      }
                    }}
                    disabled={!balances[symbol] || parseFloat(balances[symbol]) === 0}
                  >
                    75%
                  </Button>
                  <Button
                    variant="outline"
                    size="sm"
                    className="bg-gray-800 border-gray-600 text-gray-300 hover:bg-gray-700"
                    onClick={() => {
                      if (balances[symbol]) {
                        setSellAmount(balances[symbol]);
                      }
                    }}
                    disabled={!balances[symbol] || parseFloat(balances[symbol]) === 0}
                  >
                    ÊúÄÂ§ß
                  </Button>
                </div>
              </div>

              <div className="bg-gray-800 p-3 rounded-lg">
                <div className="flex justify-between text-sm">
                  <span className="text-gray-400">ÊÄªËÆ° (ETH)</span>
                  <span className="text-white">{calculateTotal(sellAmount, sellPrice)}</span>
                </div>
                <div className="flex justify-between text-sm mt-1">
                  <span className="text-gray-400">ÊâãÁª≠Ë¥π (0.1%)</span>
                  <span className="text-white">{(parseFloat(calculateTotal(sellAmount, sellPrice)) * 0.001).toFixed(4)}</span>
                </div>
              </div>

              <Button
                onClick={handleSell}
                className="w-full bg-red-600 hover:bg-red-700 text-white font-semibold py-3"
                disabled={!isConnected || !sellAmount || !sellPrice || isLoading || !currentTokenInfo || parseFloat(balances[symbol]) === 0}
              >
                {!isConnected 
                  ? "ËøûÊé•Èí±ÂåÖ" 
                  : !currentTokenInfo
                  ? "‰ª£Â∏ÅÂä†ËΩΩ‰∏≠..."
                  : parseFloat(balances[symbol]) === 0
                  ? "‰ΩôÈ¢ù‰∏çË∂≥"
                  : isLoading || isConfirming
                  ? (isConfirming ? "Á°ÆËÆ§‰∏≠..." : "Â§ÑÁêÜ‰∏≠...")
                  : `ÂçñÂá∫ ${symbol}`
                }
              </Button>
            </div>
          </TabsContent>
        </Tabs>
      </CardContent>
    </Card>
  );
}
